#+title: Emacs Configuration

I prefer to use [[https://github.com/alexanderneville/nvim_config][Neovim]] for most programming tasks, however Emacs has some features which are undoubtedly very useful. /Org/ mode is a great tool for writing things and has export back-ends for both *HTML* and /Latex/, with the added benefit of some /WYSIWYM/ abstractions you might not have using markdown or another solution. Another strength of org mode is its handling of source blocks, with which you can write code notebooks and do literate programming. This document acts as a literate configuration file for Emacs...

* Startup

So that this file is rendered automatically by Github, it is called =README.org=, but Emacs will not expect its configuration to be found in a read-me file; it is the contents of =init.el= that are loaded by Emacs on startup. There are two ways the contents of a literate document could be extracted to a plain text file:

1. Load the file in Emacs and export the contents of the source blocks to a clean file.
2. Extract the contents of the source block via a emacs-lisp script or even the /init/ file itself.

The second of these options is preferable, you can bootstrap a new installation without an existing Emacs environment. A minimal =init.el= capable of loading a literate configuration might look like:

#+begin_src emacs-lisp :tangle no
(setq custom-file (locate-user-emacs-file "custom_vars.el"))
(load custom-file 'noerror 'nomessage)
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")
                         ("elpa" . "https://elpa.gnu.org/packages/")))
(package-initialize)
(unless package-archive-contents
 (package-refresh-contents))
(unless (package-installed-p 'use-package)
   (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)
(require 'org)
(org-babel-load-file
  (expand-file-name "README.org"
                   user-emacs-directory))
#+end_src

Unfortunately, this approach requires that org mode is loaded before the contents of the custom configuration. This means that package repository initialisation must take place first to ensure that a single org version is used, not loaded partially once and then again in the literate configuration. In some cases, users have been able to export the contents of a literate configuration using only primitive emacs-lisp functions, but I didn't want to work out the required regular expressions.

* Options

All of the remaining initialisation can be performed from the literate file itself. The first step is calling some functions to disable unhelpful GUI components.

#+begin_src emacs-lisp
(menu-bar-mode -1) (tool-bar-mode -1)
(scroll-bar-mode -1)
(fringe-mode '(0 . 0))
(global-auto-revert-mode 1)
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+end_src

And then set the values of some variables.

#+begin_src emacs-lisp
(setq-default indent-tabs-mode t)
(setq-default c-basic-offset 4)
(setq inhibit-startup-echo-area-message "alex" ;; use your username
      inhibit-startup-message t
      initial-scratch-message "; Hello!"
      tab-width 4
      use-dialog-box nil
      scroll-conservatively 1000
      backup-inhibited t
      auto-save-default nil
      global-auto-revert-non-file-buffers t
      x-select-enable-clipboard nil)
#+end_src

The default font is given an absolute height of =100=. The height of other fonts is specified relative to the height of the default font. In this case =:height 1.0= can be omitted.

#+begin_src emacs-lisp
(set-face-attribute 'default nil :family "Iosevka Nerd Font" :height 100)
(set-face-attribute 'variable-pitch nil :family "Noto Sans")
(set-face-attribute 'fixed-pitch nil :family "Iosevka Nerd Font")
#+end_src

* Packages

There are thousands of packages available to extend emacs. =M-x list-packages<CR>= will give you list to browse.

** Themes

The /modus themes/ are very feature rich and roll a lot of initialisation into one package. The [[https://protesilaos.com/emacs/modus-themes][official documentation]] is the best place to find out about the configuration options available.

#+begin_src emacs-lisp
(use-package modus-themes
  :config
  (setq modus-themes-mode-line '(accented)
        modus-themes-region '(accented bg-only)
        modus-themes-completions '(opinionated)
	  ; modus-themes-mixed-fonts t
        modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-paren-match '(bold underline)
        modus-themes-syntax '(faint)
        modus-themes-subtle-line-numbers t
        modus-themes-org-blocks 'gray-background
        modus-themes-scale-headings t
        modus-themes-headings
              '((1 . (1.5))
                (2 . (1.3))
                (t . (1.1)))
        modus-themes-common-palette-overrides
              '((fg-heading-1 blue)
                (fg-heading-2 cyan)
                (fg-heading-3 green)))
  (load-theme 'modus-operandi t))
#+end_src

The set of /doom emacs/ themes is also quite nice. I only ever load one of /modus/ or /doom/.

#+begin_src emacs-lisp :tangle no
(use-package doom-themes
  :ensure t
  :config
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t)
  (doom-themes-org-config)
  (load-theme 'doom-one t))

(use-package all-the-icons
  :ensure t)

(use-package doom-modeline
  :ensure t
  :hook (after-init . doom-modeline-mode)
  :config
  (setq doom-modeline-height 50))
#+end_src

** Completion

Replace the default =M-x= behaviour with a /fuzzy finder/ experience. Ivy also includes /swiper/, which is a great way to search a file that the buffer is visiting.

#+begin_src emacs-lisp
(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (setq ivy-initial-inputs-alist nil)
  (ivy-mode 1))

(use-package ivy-rich
  :init
  (ivy-rich-mode 1))

(use-package counsel
  :bind (("M-x" . counsel-M-x)
         ("C-x b" . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history)))
#+end_src

** Keybindings

I use Vi/Vim keys in emacs. It would probably be too difficult to use Emacs keys and Vi keys simultaneously in different applications. I also use the Vi keys in tmux, zsh and my window manager, so Emacs would be the exception.

#+begin_src emacs-lisp
(use-package evil
  :init
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-i-jump nil)
  :config
  (evil-mode 1)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
  (evil-global-set-key 'motion "0" 'evil-beginning-of-visual-line)
  (evil-global-set-key 'motion "$" 'evil-end-of-visual-line)
  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))

(with-eval-after-load 'evil-maps
  (define-key evil-motion-state-map (kbd "RET") nil))

(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src

Leader key configuration, similar to my Neovim configuration. /Which-key/ will show you a list of keybinding from the current point after a short delay. This replaces some of the discover-ability lost by disabling the UI.

#+begin_src emacs-lisp
(use-package general
  :config
  (general-evil-setup t)
  (general-create-definer myconfig/leader-keys
      :prefix "SPC"
      :global-prefix "C-c"))

(myconfig/leader-keys 'normal 'override
  ;; switch/navigate
  "bb" 'counsel-switch-buffer
  "ff" 'counsel-find-file
  "ss" 'swiper
  ;; functions
  "d" 'dired
  "p" 'clipboard-yank
  "y" 'clipboard-kill-ring-save
  "e" 'eval-buffer
  "x" 'counsel-M-x
  "i" 'ibuffer
  "c" 'evil-delete-buffer
  "t" 'counsel-load-theme
  ;; files
  "le" '(lambda () (interactive) (find-file "~/.config/emacs/README.org"))
  ;; org
  "or" 'org-mode-restart
  "op" 'org-latex-preview
  "otl" 'org-toggle-link-display
  "oti" 'org-toggle-inline-images
)

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.01))
#+end_src

** Programming

This is a very quick programming setup, I won't use Emacs for programming very often.

#+begin_src emacs-lisp
(use-package tree-sitter
  :config
  (global-tree-sitter-mode)
  (add-hook 'prog-mode-hook #'tree-sitter-hl-mode))
(use-package tree-sitter-langs)

(use-package lsp-mode
  :init
  (setq lsp-keymap-prefix "C-c l")
  ; :config
  ; (add-hook 'prog-mode-hook #'lsp) # do this on per file basis
  :commands lsp)

(use-package lsp-pyright
  :ensure t
  :hook (python-mode . (lambda ()
                          (require 'lsp-pyright)
                          (lsp))))
(use-package company
  :config
  (add-hook 'prog-mode-hook #'company-mode))

(use-package smartparens
  :config
  (add-hook 'prog-mode-hook #'smartparens-mode))

(use-package yasnippet
  :config
  (add-hook 'prog-mode-hook #'yas-minor-mode))
(use-package yasnippet-snippets)
#+end_src

* Org Mode

Define a function to evaluate when org mode is loaded, this is easier than many =(add-hook 'org-mode-hook ...)=.

#+begin_src emacs-lisp
(defun org-mode-setup ()
  (org-indent-mode 1)
  (visual-line-mode nil)
  ;; (variable-pitch-mode 1)
  (setq org-hide-emphasis-markers t
        org-return-follows-link  t
        org-list-allow-alphabetical t
        org-catch-invisible-edits 'smart
        org-use-sub-superscripts '{}
        org-export-with-sub-superscripts '{}
        org-src-preserve-indentation nil
        org-edit-src-content-indentation 0
        tex-fontify-script nil
        org-highlight-latex-and-related '(latex entities)
        org-src-fontify-natively t
        mode-line-format nil
        org-link-frame-setup
            '((vm . vm-visit-folder-other-frame)
              (vm-imap . vm-visit-imap-folder-other-frame)
              (gnus . org-gnus-no-new-news)
              (file . find-file)
              (wl . wl-other-frame))
  ))
#+end_src

Call the set-up function when org mode is loaded.

#+begin_src emacs-lisp
(require 'org-indent)
(require 'org-src)
(setq	org-startup-folded 'content)
(add-hook 'org-mode-hook #'org-mode-setup)
#+end_src

Structure templates make inserting source blocks much easier.

#+begin_src emacs-lisp
(require 'org-tempo)
(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
#+end_src

Org babel is used for literate programming, including handling this very file.

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)))

(setq org-confirm-babel-evaluate nil)
#+end_src

** Fonts

To use =varaible-pitch-mode=, some faces need to be set to mono-space, such as code blocks and tables.

#+begin_src emacs-lisp :tangle no
(set-face-attribute 'org-block-begin-line nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-block-end-line nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-block nil :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil :inherit 'fixed-pitch)
(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
(set-face-attribute 'org-document-info-keyword nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
#+end_src

The /mixed-pitch/ package does many of the same things.

#+begin_src emacs-lisp :tangle no
(use-package mixed-pitch
  :hook
  (org-mode . mixed-pitch-mode))
#+end_src

Change the height of the face used to display /org-mode/ headings.

#+begin_src emacs-lisp :tangle no
(dolist (face '((org-level-1 . 1.5)
                (org-level-2 . 1.4)
                (org-level-3 . 1.3)
                (org-level-4 . 1.2)
                (org-level-5 . 1.1)
                (org-level-6 . 1.1)
                (org-level-7 . 1.1)
                (org-level-8 . 1.1)
                (org-document-title . 1.6)))
  (set-face-attribute (car face) nil :family
		      (face-attribute 'variable-pitch :family)
		      :weight 'bold :height (cdr face)))
#+end_src

** Extra Packages

Optionally use a package like /org-modern/ to style the buffer. I am not using it currently.

#+begin_src emacs-lisp :tangle no
(use-package org-modern
  :hook (org-mode . org-modern-mode))
#+end_src

Most of the time I choose to hide a few org syntax elements. The /org-bullets/ package replaces the asterisks before each heading with Unicode symbols. /org-appear/ shows emphasis markers when the cursor hovers over emphasised text.

#+begin_src emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("●" "○" "●" "○" "●" "○" "●")))

(use-package org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
	org-appear-autolinks t)
  (run-at-time nil nil #'org-appear--set-elements))

#+end_src

For writing text, =visual-line-mode= is enabled. The /visual-fill-column/ package can set the point at which text wraps and centre text in the buffer, which is very helpful.

#+begin_src emacs-lisp
(use-package visual-fill-column
  :config
  (setq-default visual-fill-column-center-text t)
  (setq-default visual-fill-column-width 100))
(add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
(advice-add 'text-scale-adjust :after #'visual-fill-column-adjust)
#+end_src

** Spell Checking

An essential feature for writing text. /Ispell/ ignores words in my private dictionary and code inside source blocks. /Flycheck/ highlights possible errors in the buffer.

#+begin_src emacs-lisp
(setq
 ispell-program-name "aspell"
 ispell-local-dictionary "british-ise"
 ispell-personal-dictionary "~/.config/emacs/british-ise.pws"
)
(defun my_config/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+begin_src" . "^#\\+end_src")))
(add-hook 'org-mode-hook #'my_config/org-ispell)
(dolist (hook '(org-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
(add-hook 'flyspell-mode-hook 'flyspell-buffer)
#+end_src
